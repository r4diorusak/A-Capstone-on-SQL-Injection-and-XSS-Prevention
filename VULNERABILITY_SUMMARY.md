Vulnerability summary

Identified issues and fixes applied:

1) SQL Injection
- Issue: naive string concatenation into SQL can allow injection.
- Fix: use SQLAlchemy ORM queries which parameterize values. The `/search` endpoint uses `User.query.filter(User.username.like(...))` which binds parameters.

2) Cross-Site Scripting (XSS)
- Issue: displaying user-controlled content without escaping can execute scripts.
- Fix: templates use Jinja2 auto-escaping; user-supplied `username` is rendered safely.

Authentication & RBAC
- Implemented password hashing via Werkzeug and role field on `User` model.
- `roles_required` decorator enforces that only admins can access `/admin`.

Testing
- Added pytest tests that attempt SQL injection and XSS payloads. Tests assert that payloads are not executed or returned raw.

How Copilot assisted
- Copilot was used to scaffold common Flask patterns: app factory, user model, and typical auth flows. It suggested using `werkzeug.security` for password hashing and SQLAlchemy ORM patterns which I reviewed and adapted.

Limitations & next steps
- Add stronger input validation (WTForms), rate limiting, account lockout, CSRF protection, and use production-ready secrets and DB.
